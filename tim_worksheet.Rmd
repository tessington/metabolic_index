---
title: "Tim's Take on Taxonomic Hierarchy Modeling"
author: "Tim!"
date: "5/11/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(MASS)
```

## Tim's take on the model

From Thorson et al and Thorson (2020), but basic model for the vector of life history traits corresponding to some child  taxonomic group, $g$ is:
$$g \sim MVN(x_{p(g)}, \Sigma_{l(g)} $$
where $p(g)$ is the parent taxonomy level for child group $g$, and $\Sigma_{l(g)}$ is the evolutionary covariance, and $l(g)$ indicates the taxonomic level of gropu $g$.  For reference $l(g) =1$ refers to Class. 

The estimation procedure works by estimating a vector of elements of the lower triangular matrix, $\textbf{L}_{\Sigma}$,so the evoluationary covariance matrix equals:

$$\Sigma_{l(g)} = \lambda_l \big( \textbf{L}_{\Sigma} \textbf{L}_{\Sigma}^T + \textbf{D} \big) $$

where $\textbf{D}$ is a diagonal matrix the additional and independent evolutionary variance in traits ($\sigma_j^2$). The parameter $\lambda_{l(g)}$ is the relative amount of of covariance explained by taxonomic level $l$ relative to Taxonomic level Class (e.g. $\lambda_{l(g) =1} = 1$).

Now is where I get a little lost because there is an additional covariance matrix for the residuals:
$$\tilde{y} \sim MVN(x_{g(l)}, \textbf{V}) $$
where $\tilde{y}$ is the "augemented data for the ith study.  

Fixed effects are the evolutionary covariance ($\textbf{L}_{\Sigma}$), and the residual covariance ($\textbf{V}$)

In the TMB code, I see something like this (with my annotations):

``` {r eval = FALSE}
// Probability of random effects
  vector<Type> Parent_j( n_j );  # create vector of parent mean trait alues
  vector<Type> Prediction_j( n_j ); # create vector to hold predicted values of traits
  vector<Type> Deviation_j( n_j ); # MVN only works on 0 means, so create a vector of deviations
  matrix<Type> tmpCov_jj( n_j, n_j ); # not entirely sure, see below
  for( int g=0; g<n_g; g++ ){  # loop through each taxonomic grouping
    for( int j=0; j<n_j; j++ ){ # loop through trait
      if( PC_gz(g,1)==0 ) Parent_j(j) = alpha_j(j); # if group = Class, then look up values in alpha
      if( PC_gz(g,1)>=1 ) Parent_j(j) = betainput_gj(PC_gz(g,0),j); # otherwise, look up values in betainput
      Prediction_j(j) = Parent_j(j); # assign prediction to equal value of parent
    }
    for( int j=0; j<n_j; j++ ){
      Deviation_j(j) = betainput_gj(g,j) - Prediction_j(j); # deviations, duh
    }
    tmpCov_jj = Cov_jj * exp(cov_logmult_z(PC_gz(g,1))); # ok, this is where I have some trouble Cov_jj would seem to be the covariance of traits (thus the jj subscript), but this is multiplied by some factor that correspons to the child level.  So, am i right that the residual covariance is a multiplier of the evoluationary covariance?
    if( Options_vec(4)==false ){
      jnll_comp(PC_gz(g,1)) += MVNORM( tmpCov_jj )( Deviation_j ); # get the NLL of the vector of j traits for taxa group g
    }
  }
```
  I can see that we do indeed estimate two separate vectors L_v and obsL_v, which I'm guessing are the two different things.  The obsCov seems to rely on this:

```{r eval = FALSE}  
  matrix<int> RAMobs( 0, 5 );
  matrix<Type> obsCov_jj( n_j, n_j );
  obsCov_jj = cov_matrix( obsL_z, RAMobs, Options(0), n_j, Options_vec(0) );
```  
The rest is pretty straitforward - using the observations ($Y_{i,j}$):

```{r eval = FALSE}
// Probability of data
matrix<Type> Yhat_ij( n_i, n_j ); # get matrix of predicted values for each taxa group i
for( int i=0; i<n_i; i++){ # loop through observations
  if( Options_vec(4)==false ){ # this is a toggle to turn off taxonomic hierarchy
    Yhat_ij.row( i ) = beta_gj.row( g_i(i) );
  }else{
    Yhat_ij.row( i ) = alpha_j;
  }
  jnll_comp(5) += MVNORM( obsCov_jj )( Ycomplete_ij.row(i) - Yhat_ij.row(i) ); # get NLL
}
```

## Generating Evolutionary Data

Presume here that we have Class, Order, Family, Genus, Species, with three traits, logAo, n, and Eo.

We start with the vector $\mathbb{\alpha}$ , which is 1 x 3.  From alpha, we sample MVN using a specified vector for $L_{\Sigma}$ to get values for each Order.  For simplicity, we'll use our actual data to create the parent - child matrix

```{r generate_betas, echo = T}

alpha_j <- c(1, -0.2, -0.8) # means above class

#### Get taxonomy tree ####
all.dat <- readRDS(file = "data/alldata_taxonomy.RDS")
all.dat <- dplyr::select(all.dat, Temp, W, Pcrit, Class, Order, Family, Genera, Species)
naIndex <- which(is.na(all.dat$Species))
for (i in 1:length(naIndex)) all.dat$Species[naIndex[i]] <- paste0(all.dat$Genera[naIndex[i]], " spc")
Z_ik <- dplyr::select(all.dat, Class, Order, Family, Genera, Species)
Z_ik <- unique(Z_ik, MARGIN = 1)
ParentChild_gz = NULL
# 1st column: child taxon name
# 2nd column: parent taxon name
# 3rd column: parent row-number in ParentChild_gz
# 4th column: Taxon level
# Loop through
for( colI in 1:ncol(Z_ik)){
  Taxa_Names = apply( Z_ik[,1:colI,drop=FALSE], MARGIN=1, FUN=paste, collapse="_")
  Unique_Taxa = unique(Taxa_Names)
  for( uniqueI in 1:length(Unique_Taxa) ){
    Which = which( Taxa_Names == Unique_Taxa[uniqueI] )
    if( colI==1 ){
      ParentChild_gz = rbind( ParentChild_gz, c(Unique_Taxa[uniqueI], NA, NA, colI) )
    }else{
      if( length(unique(Z_ik[Which,colI-1]))>1 ) stop("Taxa has multiple parents")
      ChildName = Unique_Taxa[uniqueI]
      ParentName = paste(rev(rev(strsplit(ChildName,"_")[[1]])[-1]),collapse="_")
      ParentChild_gz = rbind( ParentChild_gz, c(ChildName, ParentName, match(ParentName,ParentChild_gz[,1]), colI) )
    }
  }
}

# Add top predictive
ParentChild_gz = rbind( ParentChild_gz, c("predictive", NA, NA, 1) )
for( colI in 2:ncol(Z_ik)) ParentChild_gz = rbind( ParentChild_gz, c(paste(rep("predictive",colI),collapse="_"), paste(rep("predictive",colI-1),collapse="_"), match(paste(rep("predictive",colI-1),collapse="_"),ParentChild_gz[,1]), colI) )
# Relabel
ParentChild_gz = data.frame( ParentChild_gz )
colnames(ParentChild_gz) = c("ChildName", "ParentName", "ParentRowNumber", "ChildTaxon")
ParentChild_gz[,'ParentRowNumber'] = as.numeric(as.character(ParentChild_gz[,'ParentRowNumber']))
ParentChild_gz[,'ChildTaxon'] = as.numeric(as.character(ParentChild_gz[,'ChildTaxon']))
PC_gz = as.matrix(ParentChild_gz[, c('ParentRowNumber', 'ChildTaxon')]) 
# Identify location for every observation
Taxa_Names = apply( Z_ik, MARGIN=1, FUN=paste, collapse="_")
g_i = match( Taxa_Names, ParentChild_gz[,'ChildName'] )
n_k = ncol(Z_ik)
n_j = 3 # three traits
n_g = nrow(ParentChild_gz)
n_i <- length(g_i)


# Specify all parameters
# lambda - relative covariance w/in groups
lambda_g <- c(1, 0.8, 0.6, 0.5, 0.3, 0.3)
# Specify  variance covariance and generate L_z
sigma1 <- 0.25
sigma2 <- 2
sigma3 <- 0.2
rho12 <- 0.5
rho13 <- 0.25
rho23 <- 0.5
L_z <- c(sigma1, sigma1 * sigma2 * rho12, sigma1 * sigma3 * rho13, sigma2, sigma2 * sigma3 * rho23, sigma3)
L_zobs <- L_z * 0.5 


 ### Create evolutionary covariance matrix
cov_matrix <- function(L_val, logmult_col, min_var, n_rows, n_cols, invertTF ){
  L_rc<- matrix(0, n_rows, abs(n_cols))
  Cov_rr <- matrix(0, n_rows, n_rows);
  Return_rrN <- matrix(0, n_rows, n_rows);
  
  # Loadings matrix with zero upper-diagonal
  Count = 1;
  if(n_cols!=0 ){
    for(r in 0:(n_rows -1)){
      for(c in 0:(n_cols -1)){
        if(r>=c){
          L_rc[r+1,c+1] = L_val[Count]
          Count <- Count +1 
        }else{
          L_rc[r+1,c+1] = 0.0
        }
      }
    for(c in 0:(n_cols-1)){
      L_rc[,c+1] = L_rc[,c+1] * exp(logmult_col[c+1])
    }
    }
  }
  ## Diagonal matrix
  if( n_cols<=0 ){
    for( r in 0:(n_rows-1)){
      Cov_rr[r+1,r+1] = L_val[Count]*L_val[Count]
      Count <- Count + 1
    }
  }
  ## Additive constant on diagonal
  for(r in 0:(n_rows -1)){
    Cov_rr[r+1,r+1] = Cov_rr[r+1,r+1] + min_var # Necesary to prevent crashes during innner optimizer when using SR data
  }
  ## Combine and return
  Cov_rr = Cov_rr + L_rc %*% t(L_rc)
  if(invertTF==FALSE) Return_rr = Cov_rr
  if(invertTF==TRUE) Return_rr = atomic::matinv( Cov_rr )
  return (Return_rr)
}


Parent_j <- rep(0, n_j)
Prediction_j <- rep(0, n_j)
Deviation_j <- rep(0, n_j)
tmpCov_jj <- matrix(0, n_j, n_j)

beta_gj <- matrix(0, n_g, n_j)

Cov_z <- cov_matrix(L_z, logmult_col = c(0,0,0), min_var = 0.01,  n_rows = 3, n_cols = 3, invertTF = FALSE)
for(g in 1:n_g){
    if( PC_gz[g,2]==1 ) {
      Parent_j <- alpha_j + mvrnorm(n = 1, mu = rep(0, 3), Sigma = Cov_z)
      beta_gj[g,] <- Parent_j
    }
    if( PC_gz[g,2]>=2 ) {
      tmpCov_z <- Cov_z * lambda_g[PC_gz[g,2]]
      Parent_j = beta_gj[PC_gz[g,2],] + mvrnorm(n = 1, mu = rep(0, 3), Sigma = tmpCov_z)
      beta_gj[g,] <- Parent_j
    }
  }
  

```

Now generate data from these expected values

```{r makedata, echo = T}
Y_ij <- Yhat_ij <- matrix(0,  n_i, n_j )
Cov_zobs <- cov_matrix(L_zobs, logmult_col = c(0,0,0), min_var = 0.01,  n_rows = 3, n_cols = 3, invertTF = FALSE)
for(i in 1:n_i){
    Yhat_ij[ i, ] = beta_gj[g_i[i], ]
    Y_ij[i,] <- Yhat_ij[i,] + mvrnorm(n = 1, mu = rep(0,3), Sigma = Cov_zobs)
}

```

Set up code for TMB model fitting

```{r setupTMB, echo = F}
library(TMB)
compile.and.load <- function(model) {
  compile(paste0("code/TMB/", model, ".cpp"))
  return(dyn.load(dynlib(paste0("src/TMB/",model))))
}


model <- "hierarchical_mi"

compile.and.load(model)
```
