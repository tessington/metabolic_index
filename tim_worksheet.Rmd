---
title: "Hierarchical Estimation of Metabolic Index Parameters"
author: "Tim!"
date: "6/01/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(MASS)
```

## Basic Model structure

### Metabolic Index

The metabolic index is the ratio of metabolic demands to metabolic supply, both expressed as Arrhenius equations:

$$\phi = pO_2 A_o W^n \exp\bigg(\frac{E_o}{k_b} \big(\frac{1}{T} - \frac{1}{T_{ref}}\big) \bigg) $$
where $T$ is temperature (degrees Kelvin), $T_{ref}$ is a specified reference temperature (here chosen to be 15 degrees C), $pO_2$ is the partial pressure of oxygen (in kPa), $W$ is body size, $k_b$ is Boltzmann's constant, and $A_o$, , $n$ and $E_o$ are estimated parameters.  Thus, for any taxa, we define the vector $\textbf{g}$ as the true mean values of these three parameters for each species.

### Paramater Estimation 
To estimate these parameters hierarchically, we use the evolutionary random walk model used for other life history traits as described by Thorson (2020).  The model tracks the mean values of any taxonomic grouping (the "child") as a function of the mean values of the higher taxonomic group (the "parent") in which the taxa is nested.  For instance, the mean value for a particular Order will depend on the mean value for that Order's Class.  The distribution of trait values within a parent taxonomic grouping is described by a multivariate normal distribution:

$$\textbf{g} \sim MVN(\textbf{x}_{p(g)}, \Sigma_{l(g)} $$
where $p(g)$ is the parent taxonomy level for child group $g$, and $\Sigma_{l(g)}$ is the evolutionary covariance, and $l(g)$ indicates the taxonomic level of group $g$.  For reference $l(g) =1$ refers to Class. 

The estimation procedure works by estimating a vector of elements of the lower triangular matrix, $\textbf{L}_{\Sigma}$,so the evoluationary covariance matrix equals:

$$\Sigma_{l(g)} = \lambda_l \big( \textbf{L}_{\Sigma} \textbf{L}_{\Sigma}^T + \textbf{D} \big) $$

where $\textbf{D}$ is a diagonal matrix of the additional and independent evolutionary variance in traits ($\sigma_j^2$). The parameter $\lambda_{l(g)}$ is the relative amount of of covariance explained by taxonomic level $l$ relative to taxonomic level Class (e.g. $\lambda_{l(g) =1} = 1$).

Currently, the diagonal elements of $D$ are not explicitly being included in the estimation.
If we assume that the critical values are those that make $\phi = 1$, we re-arrange the first equation and add random error, then for each experimental observation $i$:
$$ -\log(pO_{2,crit,i} = \log(A_{o,g[i]}) + n_{g[i]} \log(W_i) + E_{o, g[i]} T'_i + \epsilon_i $$
where
$$T'_i = \bigg(\frac{1}{k_b} \big(\frac{1}{T_i} - \frac{1}{T_{ref}} \big) \bigg) $$

and
$$e_i \sim N(0, \sigma) $$

### The Data

Penn and Duetsch have compiled several experimental studies relating $pO_{2,crit}$ to temperature and oxygen to which Essington et al. (2022) added information for an additional four species.  A brief summary of the number of experimental studies by taxonomic grouping is below

```{r sumdata, echo = FALSE}
library(dplyr)
library(MASS)
library(TMB)
library(ggplot2)
library(gridExtra)


### Functions ####
find_index <- function(x,y) y <- which(y == x)
plotest <- function(dataest, trait, groupname) {
  # make min and max
  eval(parse(text = paste0("dataest$min <- dataest$", trait,"mle - 
  dataest$",trait,"se")))
  eval(parse(text = paste0("dataest$max <- dataest$", trait,"mle + 
  dataest$",trait,"se")))
  
  
  groupplot <- ggplot(data = dataest, aes_string(x = paste0(trait, "mle"), y = groupname)) +
    geom_point() +
    geom_errorbar(aes_string(y = groupname,
                             xmin = "min",
                             xmax = "max")
    )
  return(groupplot)
}

### Generate Evolutionary Trait Structure ####

#### Get taxonomy tree ####
all.dat <- readRDS(file = "data/alldata_taxonomy.RDS")
# remove data where there is no body size data
all.dat <- dplyr::filter(all.dat, !is.na(W))
naIndex <- which(is.na(all.dat$Species))
for (i in 1:length(naIndex)) all.dat$Species[naIndex[i]] <- paste0(all.dat$Genera[naIndex[i]], " spc")


# describe the data a bit - how many unique  order per class, families per order, etc.
class_summary <- all.dat %>%
  group_by(Class) %>%
  summarise(NoOrder = length(unique(Order)))
print(class_summary, n = 30)

order_summary <- all.dat %>%
  group_by(Order) %>%
  summarise(NoFamily = length(unique(Family)))
print(order_summary, n = 50)

family_summary <- all.dat %>%
  group_by(Family) %>%
  summarise(NoGenus = length(unique(Genera)))
print(family_summary, n = 70)
```

# Model Estimates

``` {r runmodel, echo = F}
find_index <- function(x,y) y <- which(y == x)
plotest <- function(dataest, trait, groupname) {
  # make min and max
  eval(parse(text = paste0("dataest$min <- dataest$", trait,"mle - 
  dataest$",trait,"se")))
  eval(parse(text = paste0("dataest$max <- dataest$", trait,"mle + 
  dataest$",trait,"se")))
  
  
  groupplot <- ggplot(data = dataest, aes_string(x = paste0(trait, "mle"), y = groupname)) +
    geom_point() +
    geom_errorbar(aes_string(y = groupname,
                             xmin = "min",
                             xmax = "max")
    )
  return(groupplot)
}


### Setup TMB data and parameters ####
#### Create new ParentChild matrix for reduced taxonomic structure ####
kb <-  8.617333262145E-5
tref <- 15
all.dat$inv.temp <- (1 / kb) * (1 / (all.dat$Temp + 273.15) - 1/(tref + 273.15))
all.dat$minuslogpo2 <- - log(all.dat$Pcrit)
taxa.list <- c("Class", "Order", "Family", "Species")


Z_ik_main <- dplyr::select(all.dat, all_of(taxa.list))
Z_ik <- unique(Z_ik_main, MARGIN = 1)
ParentChild_gz = NULL
# 1st column: child taxon name
# 2nd column: parent taxon name
# 3rd column: parent row-number in ParentChild_gz
# 4th column: Taxon level
# Loop through
for( colI in 1:ncol(Z_ik)){
  Taxa_Names = apply( Z_ik[,1:colI,drop=FALSE], MARGIN=1, FUN=paste, collapse="_")
  Unique_Taxa = unique(Taxa_Names)
  for( uniqueI in 1:length(Unique_Taxa) ){
    Which = which( Taxa_Names == Unique_Taxa[uniqueI] )
    if( colI==1 ){
      ParentChild_gz = rbind( ParentChild_gz, c(Unique_Taxa[uniqueI], NA, NA, colI) )
    }else{
      if( length(unique(Z_ik[Which,colI-1]))>1 ) stop("Taxa has multiple parents")
      ChildName = Unique_Taxa[uniqueI]
      ParentName = paste(rev(rev(strsplit(ChildName,"_")[[1]])[-1]),collapse="_")
      ParentChild_gz = rbind( ParentChild_gz, c(ChildName, ParentName, match(ParentName,ParentChild_gz[,1]), colI) )
    }
  }
}

# Relabel
ParentChild_gz = data.frame( ParentChild_gz )
colnames(ParentChild_gz) = c("ChildName", "ParentName", "ParentRowNumber", "ChildTaxon")
ParentChild_gz[,'ParentRowNumber'] = as.numeric(as.character(ParentChild_gz[,'ParentRowNumber']))
ParentChild_gz[,'ChildTaxon'] = as.numeric(as.character(ParentChild_gz[,'ChildTaxon']))
PC_gz<- as.matrix(ParentChild_gz[, c('ParentRowNumber', 'ChildTaxon')]) - 1
# Identify location for every observation
Taxa_Names = apply( Z_ik, MARGIN=1, FUN=paste, collapse="_")
g_i = match( Taxa_Names, ParentChild_gz[,'ChildName'] )
n_k = ncol(Z_ik)
n_j = 3 # three traits
n_g = nrow(ParentChild_gz)
n_i <- length(g_i)

#### Create index of data to Parent - Child ####
#Z_ik_dat <- dplyr::select(all.dat, Class, Order, Family, Species)
Taxa_Names_dat <-  apply( Z_ik_main, MARGIN=1, FUN=paste, collapse="_")
g_i_dat = match( Taxa_Names_dat, ParentChild_gz[,'ChildName'] )
g_i_i <- sapply(FUN = find_index, X = g_i_dat, y = g_i)

# Create index of species to Parent  - Child
spc_in_PC_gz <- which(PC_gz[,2] == max(PC_gz[,2]))

data <- list(PC_gz = PC_gz,
             g_i = g_i - 1,
             invtemp = all.dat$inv.temp,
             logW = log(all.dat$W),
             taxa_id = g_i_i -1,
             minuslogpo2 = all.dat$minuslogpo2,
             spc_in_PCgz = spc_in_PC_gz -1
             
)

parameters = list(alpha_j = rep(0,n_j),
                  L_z = rep(1, 6),
                  log_lambda = rep(0, length(unique(PC_gz[,2])) -1),
                  beta_gj = matrix(0, nrow = n_g, ncol = n_j),
                  logsigma = 0
)
Random <- c("beta_gj")

model <- "hierarchical_mi"
compile(paste0("code/TMB/", model, ".cpp"))
dyn.load(dynlib(paste0("code/TMB/",model)))


obj <-
  MakeADFun(
    data = data,
    parameters = parameters,
    DLL = model,
    random = Random,
    silent = TRUE
  )
opt <- nlminb(obj$par, obj$fn, obj$gr)
rep = sdreport( obj,
                getReportCovariance = FALSE)
summary(rep, "fixed")
re <- summary(rep, "report")
spc_parameters <- re[grep(rownames(re), pattern  = "spc_ij"),1]
spc_parameters_se <-re[grep(rownames(re), pattern  = "spc_ij"),2]
spc_ij_mle <- matrix(spc_parameters, nrow = n_i, ncol = 3, byrow = F)
spc_ij_se <- matrix(spc_parameters_se, nrow = n_i, ncol = 3, byrow = F)

re <- summary(rep, "random")
beta_mle <- matrix(re[grep(rownames(re), pattern = "beta"),1], nrow = n_g, ncol = 3, byrow = F)
beta_se <- matrix(re[grep(rownames(re), pattern = "beta"),2], nrow = n_g, ncol = 3, byrow = F)


### Plot Estimates ####

ClassEst <- tibble(Class = ParentChild_gz$ChildName[1:11],
                   logAomle = beta_mle[1:11,2],
                   logAose = beta_se[1:11,2],
                   Eomle = beta_mle[1:11,3],
                   Eose = beta_se[1:11,3],
                   nmle = beta_mle[1:11,1],
                   nse = beta_se[1:11, 1])



Aoplot <- plotest(ClassEst, "logAo", "Class")
Eoplot <- plotest(ClassEst, "Eo", "Class")
nplot <- plotest(ClassEst, "n", "Class")

grid.arrange(Aoplot, nplot, Eoplot, ncol = 3)


### Plot actinopterygii ####
actinIndex <- grep(x = ParentChild_gz$ParentName, pattern = "\\bActinopteri\\b")
longOrderNames <- ParentChild_gz$ChildName[actinIndex]

# Remove all before and up to ":":
OrderNames <- gsub(".*_","",longOrderNames)

ActinEst <- tibble(Order = OrderNames,
                   logAomle = beta_mle[actinIndex,2],
                   logAose = beta_se[actinIndex,2],
                   Eomle = beta_mle[actinIndex,3],
                   Eose = beta_se[actinIndex,3],
                   nmle = beta_mle[actinIndex,1],
                   nse = beta_se[actinIndex,1]
)

Aoplot <- plotest(ActinEst, "logAo", "Order")
Eoplot <- plotest(ActinEst, "Eo", "Order")
nplot <- plotest(ActinEst, "n", "Order")

grid.arrange(Aoplot, nplot, Eoplot, ncol = 3)

# plot all species
longSpeciesNames <- ParentChild_gz$ChildName[ParentChild_gz[,'ChildTaxon']==4]
SpeciesNames <- gsub(".*_","",longSpeciesNames)
SpeciesEst <- tibble(Species = SpeciesNames,
                 logAomle =spc_ij_mle[,2],
                 logAose = spc_ij_se[,2],
                 Eomle = spc_ij_mle[,3],
                 Eose = spc_ij_se[,3],
                 nmle = spc_ij_mle[,1],
                 nse = spc_ij_se[,1]
)
Aoplot <- plotest(SpeciesEst, "logAo", "Species")
Aoplot
Eoplot <- plotest(SpeciesEst, "Eo", "Species")
Eoplot
nplot <- plotest(SpeciesEst, "n", "Species")
nplot
#grid.arrange(Aoplot, nplot, Eoplot, ncol = 3)

```


The data do not allow us to estimate Order-level mean trait values, as the maximum likelihood estimate of $lambda_{[l=2]}$ is converging to 0 i.e., the estimated variance of traits among orders within a class is zero.  This is not an inherent problem with the structure of the data: I have simulated the data using the same structure and find that I can reliably estimate order-level mean trait values.  Rather, it suggests that there is not sufficient variation across Orders given the variation in species within Orders and Families.

Nonetheless, the estimated parameters largely make sense, and we minimally can generate priors for an out-of-sample taxa based on Class (though the differences there are small) or Family (where we have limited taxonomic coverage).

It is notable that the estimated body size coefficients are so close to 0.  In my simulation testing it was very hard to accurately estimate $n$ unless there were really huge differences among taxa (and even then it was tough).  My guess it is because a lot of experiments / taxa don't have enough sizes to inform this, and the cross-species comparisons are heavily confounded with taxonomy.  

# What does it mean
This is a decent starting point for integrating into species distribution modeling.  Comparing spatially explicit models with statistical presence-only data will be a useful next step.